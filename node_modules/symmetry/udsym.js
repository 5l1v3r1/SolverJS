/**
 * Cube symmetry along the U/D axis
 * @argument z2 A boolean (true if z2 should be applied)
 * @argument y The exponent from 0 to 4 of a y rotation
 * @argument mirror A boolean (true if an x-axis flip should occur)
 * @discussion Applies the function z2^a + y^b + mirror^c
 */
function UDSym(z2, y, mirror) {
    this.z2 = z2;
    this.y = y;
    this.mirror = mirror;
}

UDSym.prototype.inverse = function() {
    if (!this.z2 && !this.mirror) {
        return new UDSym(false, 4 - this.y, false);
    }
    return this;
}

/**
 * Applies aSym to this symmetry of the cube.
 * Returns aSym * this
 */
UDSym.prototype.apply = function(aSym) {
    var resZ2 = (aSym.z2 ^ this.z2) == 1;
    var resMirror = (aSym.mirror ^ this.mirror) == 1;
    var resY = 0;
    if (this.mirror) {
        if (aSym.z2) {
            resY = (this.y + aSym.y) % 4;
        } else {
            resY = Math.abs((this.y - aSym.y) % 4);
        }
    } else {
        if (aSym.z2) {
            resY = Math.abs((this.y - aSym.y) % 4);
        } else {
            resY = (this.y + aSym.y) % 4;
        }
    }
    return new UDSym(resZ2, resY, resMirror);
}

function generate() {
    var list = [];
    for (var y = 0; y < 4; y++) {
        list.push(new UDSym(false, y, false));
        list.push(new UDSym(false, y, true));
        list.push(new UDSym(true, y, false));
        list.push(new UDSym(true, y, true));
    }
    return list;
}

exports.UDSym = UDSym;
exports.generate = generate;
