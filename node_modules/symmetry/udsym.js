var Box = require('./box.js').Box;

var applicationTable = null;

/**
 * Cube symmetry along the U/D axis
 * @argument z2 A boolean (true if z2 should be applied)
 * @argument y The exponent from 0 to 4 of a y rotation
 * @argument mirror A boolean (true if an x-axis flip should occur)
 * @discussion Applies the function z2^a + y^b + mirror^c
 */
function UDSym(z2, y, mirror) {
    this.z2 = z2;
    this.y = y;
    this.mirror = mirror;
}

UDSym.prototype.toString = function() {
    return '(z2=' + this.z2 + ', y=' + this.y + ', mirror=' + this.mirror + ')';
}

UDSym.prototype.hash = function() {
    return this.y | (this.z2 ? 1 << 2 : 0) | (this.mirror ? 1 << 3 : 0);
}

/**
 * Inverts a symmetry operation
 */
UDSym.prototype.inverse = function() {
    if (this.z2 == this.mirror) {
        return new UDSym(this.z2, (4 - this.y) % 4, this.mirror);
    }
    return this;
}

/**
 * Applies aSym to this symmetry of the cube.
 * Returns aSym * this
 */
UDSym.prototype.apply = function(aSym) {
    if (!applicationTable) {
        applicationTable = generateTable();
        console.log(JSON.stringify(applicationTable));
    }
    return applicationTable[this.hash()][aSym.hash()];
}

/**
 * Creates a UDSym from a Box if it exists
 */
function fromBox(aBox) {
    for (var y = 0; y < 4; y++) {
        for (var z2 = 0; z2 < 2; z2++) {
            for (var flip = 0; flip < 2; flip++) {
                var box = (new Box()).rotateZ2(z2 == 1).rotateY(y).flipLR(flip == 1);
                if (box.equals(aBox)) {
                    return new UDSym(z2 == 1, y, flip == 1);
                }
            }
        }
    }
    return null;
}

/**
 * Generates a list (not in a defined order) of all
 * possible U/D symmetries.
 */
function generate() {
    var list = [];
    for (var y = 0; y < 4; y++) {
        list.push(new UDSym(false, y, false));
        list.push(new UDSym(false, y, true));
        list.push(new UDSym(true, y, false));
        list.push(new UDSym(true, y, true));
    }
    return list;
}

exports.UDSym = UDSym;
exports.generate = generate;
exports.fromBox = fromBox;

/** Private **/

function generateTable() {
    var symmetries = generate();
    var symmetryBoxes = new Array(16);
    for (var i = 0; i < 16; i++) {
        var sym = symmetries[i];
        var box = (new Box()).rotateZ2(sym.z2).rotateY(sym.y).flipLR(sym.mirror);
        symmetryBoxes[i] = box;
    }
    
    var table = new Array(16);
    for (var i = 0; i < 16; i++) {
        var products = new Array(16);
        var sym = symmetries[i];
        var box = symmetryBoxes[i];
        // apply each symmetry to it
        for (var j = 0; j < 16; j++) {
            var aSym = symmetries[j];
            var aBox = symmetryBoxes[j];
            var product = box.apply(aBox);
            var result = fromBox(product);
            products[aSym.hash()] = result;
        }
        table[sym.hash()] = products;
    }
    
    return table;
}
