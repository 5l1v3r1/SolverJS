var cube = require('cube');
var udsym = require('./udsym.js');

/**
 * Pass this a bunch of State objects and it will use nice
 * symmetry to reduce the number of states for your pruning
 * tables.
 */
function SymTable(allStates) {
    var symmetries = leastSymmetries(allStates);
    this.symmetries = symmetries.map;
    this.leastStates = symmetries.states;
    
    var hashInfo = perfectHashTable(this.symmetries);
    this.hashTable = hashInfo.map;
    this.hashTableCount = hashInfo.count;
}

SymTable.prototype.leastSymmetry = function(state) {
    return this.symmetries[state.hash()];
}

SymTable.prototype.perfectHash = function(leastState) {
    return this.hashTable[leastState.hash()];
}

SymTable.prototype.perfectHashCount = function() {
    return this.hashTableCount;
}

SymTable.prototype.getAllLeastStates = function() {
    return this.leastStates;
}

exports.SymTable = SymTable;

// Internal Methods

/**
 * Returns an array of State hashes which
 * correspond to an object {'sym': s, 'state': m}
 */
function leastSymmetries(allStates) {
    var symmetries = udsym.generate();
    var leastStates = new Array();
    var object = new Array(allStates.length);
    // optimization technique for V8
    for (var i = 0; i < allStates.length; i++) {
        object[i] = null;
    }
    for (var i = 0; i < allStates.length; i++) {
        var state = allStates[i];
        var leastHash = 1<<30, leastState = null, leastSym = null;
        
        if (object[state.hash()]) continue;
        
        var computedStates = new Array(16);
        for (var j = 0; j < symmetries.length; j++) {
            var aState = state.symmetrize(symmetries[j]);
            if (aState.hash() < leastHash) {
                leastHash = aState.hash();
                leastState = aState;
                leastSym = symmetries[j];
            }
            computedStates[j] = aState;
        }
        for (var j = 0; j < symmetries.length; j++) {
            var aState = computedStates[j];
            var applied = symmetries[j].inverse().apply(leastSym);
            
            // TODO: delete this test
            var shouldWork = aState.symmetrize(applied);
            if (shouldWork.hash() != leastState.hash()) {
                var mightWork = shouldWork.symmetrize(new udsym.UDSym(0, 2, 0));
                console.log('leastState ' + JSON.stringify(leastState));
                console.log('shouldWork ' + JSON.stringify(shouldWork));
                console.log('aState ' + JSON.stringify(aState));
                console.log('state ' + JSON.stringify(state));
                console.log('symmetries[j] ' + JSON.stringify(symmetries[j]));
                console.log('leastSym ' + JSON.stringify(leastSym));
                console.log('applied ' + applied);
                console.log('might work ' + JSON.stringify(mightWork));
                throw 'Fucking A';
            }
            
            // here's how I calculate the `applied` symmetry:
            // aState = state.symmetrize(symmetries[j]);
            // leastState = aState.symmetrize(symmetries[j].inverse()).symmetrize(leastSym)
            object[aState.hash()] = {'sym': applied, 'state': leastState};
        }
        leastStates.push(leastState);
    }

    return {'map': object, 'states': leastStates};
}

/**
 * Takes the result of leastSymmetries and converts it to
 * {aHash: index, anotherHash: index, ...}
 */
function perfectHashTable(mapping) {
    var index = 0;
    var hashCount = 0;
    for (var i = 0; i < mapping.length; i++) {
        var state = mapping[i].state;
        if (hashCount < state.hash()) {
            hashCount = state.hash();
        }
    }
    var aMap = new Array(hashCount);
    for (var i = 0; i < hashCount; i++) {
        aMap[i] = -1;
    }
    for (var i = 0; i < mapping.length; i++) {
        var state = mapping[i].state;
        if (aMap[state.hash()] >= 0) {
            continue;
        }
        index++;
        aMap[state.hash()] = index;
    }
    return {'count': index, 'map': aMap};
}
