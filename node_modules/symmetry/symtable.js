var cube = require('cube');
var udsym = require('./udsym.js');

/**
 * Pass this a bunch of State objects and it will use nice
 * symmetry to reduce the number of states for your pruning
 * tables.
 */
function SymTable(allStates) {
    this.symmetries = leastSymmetries(allStates);
    this.hashTable = perfectHashTable(this.symmetries);
}

SymTable.prototype.leastSymmetry = function(state) {
    return this.symmetries[state.hash()];
}

SymTable.prototype.perfectHash = function(leastState) {
    return this.hashTable[leastState.hash().toString()];
}

SymTable.prototype.perfectHashCount = function() {
    return Object.keys(this.hashTable).length;
}

SymTable.prototype.getAllLeastStates = function() {
    var allHashes = [];
    var allMaps = [];
    for (var i = 0; i < this.symmetries.length; i++) {
        var obj = this.symmetries[i];
        if (allHashes.indexOf(obj.state.hash()) >= 0) continue;
        allHashes.push(obj.state.hash());
        allMaps.push(obj.state);
    }
    return allMaps;
}

exports.SymTable = SymTable;

// Internal Methods

/**
 * Returns an array of State hashes which
 * correspond to an object {'sym': s, 'state': m}
 */
function leastSymmetries(allStates) {
    var symmetries = udsym.generate();
    var object = new Array(allStates.length);
    // optimization technique for V8
    for (var i = 0; i < allStates.length; i++) {
        object[i] = null;
    }
    for (var i = 0; i < allStates.length; i++) {
        var state = allStates[i];
        var leastHash = 1<<30, leastState = null, leastSym = null;
        
        if (object[state.hash()]) continue;
        
        var computedStates = new Array();
        for (var j = 0; j < symmetries.length; j++) {
            var aState = state.symmetrize(symmetries[j]);
            if (aState.hash() < leastHash) {
                leastHash = aState.hash();
                leastState = aState;
                leastSym = symmetries[j];
            }
            computedStates.push(aState);
        }
        for (var j = 0; j < symmetries.length; j++) {
            var aState = computedStates[j];
            var applied = symmetries[j].inverse().apply(leastSym);
            // here's how I calculate the `applied` symmetry:
            // aState = state.symmetrize(symmetries[j]);
            // leastState = aState.symmetrize(symmetries[j].inverse()).symmetrize(leastSym)
            object[aState.hash()] = {'sym': applied, 'state': leastState};
        }
    }

    return object;
}

/**
 * Takes the result of leastSymmetries and converts it to
 * {aHash: index, anotherHash: index, ...}
 */
function perfectHashTable(mapping) {
    var aMap = {};
    var index = 0;
    for (var i = 0; i < mapping.length; i++) {
        var object = mapping[i];
        if (aMap[object.state.hash().toString()] != undefined) {
            continue;
        }
        index++;
        aMap[object.state.hash().toString()] = index;
    }
    return aMap;
}
