var cube = require('cube');

/**
 * Pass this a bunch of State objects and it will use nice
 * symmetry to reduce the number of states for your pruning
 * tables.
 */
function SymTable(allStates) {
    this.symmetries = leastSymmetries(allStates);
    this.hashTable = perfectHashTable(this.symmetries);
}

SymTable.prototype.leastSymmetry = function(state) {
    return this.symmetries[state.hash().toString()];
}

SymTable.prototype.perfectHash = function(leastState) {
    return this.hashTable[leastState.hash().toString()];
}

SymTable.prototype.perfectHashCount = function() {
    return Object.keys(this.hashTable).length;
}

exports.SymTable = SymTable;

// Internal Methods

/**
 * Returns a map of State hashes which
 * correspond to an object {'sym': s, 'state': m}
 */
function leastSymmetries(allStates) {
    var symmetries = cube.udsym.generate();
    var object = {};
    for (var i = 0; i < allStates.length; i++) {
        var state = allStates[i];
        var leastHash = 1<<30, leastState = null, leastSym = null;
        
        for (var j = 0; j < symmetries.length; j++) {
            var aState = state.symmetrize(symmetries[j]);
            if (aState.hash() < leastHash) {
                leastHash = aState.hash();
                leastState = aState;
                leastSym = symmetries[j];
            }
        }
        
        var stateKey = state.hash().toString();
        object[stateKey] = {'sym': leastSym, 'state': leastState};
    }
    return object;
}

/**
 * Takes the result of leastSymmetries and converts it to
 * {aHash: index, anotherHash: index, ...}
 */
function perfectHashTable(mapping) {
    var aMap = {};
    var index = 0;
    for (var key in mapping) {
        var object = mapping[key];
        if (aMap[object.state.hash().toString()] != undefined) {
            continue;
        }
        index++;
        aMap[object.state.hash().toString()] = index;
    }
    return aMap;
}
