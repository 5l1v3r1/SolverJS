var table = require('./table.js');
var State = require('../state.js').State;

function EdgeOrientations(orientations, eslice) {
    State.call(this);
    if (orientations) this.orientations = orientations;
    else {
        this.orientations = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    }
    this.eslice = eslice;
    if (this.orientations.length == 11) {
        var even = true;
        for (var i = 0; i < 11; i++) {
            if (this.orientations[i]) even = !even;
        }
        if (even) this.orientations.push(0);
        else this.orientations.push(1);
    }
}

EdgeOrientations.prototype = Object.create(State.prototype);

EdgeOrientations.prototype.generateHash = function() {
    var eoHash = 0;
    for (var i = 0; i < 11; i++) {
        eoHash |= (this.orientations[i] ? 1 : 0) << i;
    }
    var sliceHash = this.eslice.hash() * (1 << 11);
    return sliceHash + eoHash;
}

EdgeOrientations.prototype.hashCount = function() {
    return (1 << 11) * this.eslice.hashCount();
}

EdgeOrientations.prototype.move = function(move) {
    var slots = null, pieces = null;
    var transformation = table.EdgeTable[move.face];
    if (move.power == 1) {
        slots = transformation[0];
        pieces = transformation[1];
    } else if (move.power == 2) {
        slots = transformation[0];
        pieces = transformation[2];
    } else if (move.power == 3) {
        slots = transformation[1];
        pieces = transformation[0];
    } else {
        throw 'Unsupported power ' + move.power;
    }
    
    var flags = this.orientations.slice(0);
    var flipFlag = move.face < 2 ? (move.power != 2 ? 1 : 0) : 0
    for (var i = 0; i < 4; i++) {
        var value = this.orientations[pieces[i]];
        flags[slots[i]] = value ^ flipFlag;
    }
    
    // change the slice edges as well and then return
    var newslice = this.eslice.move(move);
    return new EdgeOrientations(flags, newslice);
}

EdgeOrientations.prototype.rotateZ2 = function(flag) {
    if (!flag) return this;
    var newFlags = new Array(12);
    for (var i = 0; i < 12; i++) {
        newFlags[i] = this.orientations[table.EdgeZ2Rotation[i]];
    }
    return new EdgeOrientations(newFlags, this.eslice.rotateZ2(flag));
}

EdgeOrientations.prototype.rotateY = function(yPower) {
    if (yPower == 0) return this;
    
    var transformation = [table.EdgeYRotation, table.EdgeY2Rotation,
                          table.EdgeY3Rotation][yPower - 1];
    if (transformation == undefined) {
        throw 'Unsupported yPower ' + yPower;
    }
    
    // apply the transformation
    var newFlags = new Array(12);
    for (var i = 0; i < 12; i++) {
        newFlags[i] = this.orientations[transformation[i]];
    }
    
    var neweslice = this.eslice.rotateY(yPower);
    
    // adjust edge orientations if necessary
    if (yPower % 2 != 0) {
        for (var i = 0; i < 12; i++) {
            newFlags[i] ^= neweslice.isSliceEdge(i);
            if (i == 1 || i == 3 || i == 7 || i == 9) { // e slice slot
                newFlags[i] ^= 1;
            }
        }
    }
    
    return new EdgeOrientations(newFlags, neweslice);
}

EdgeOrientations.prototype.flipLR = function(flag) {
    if (!flag) return this;
    var swapLeft = [4, 3, 10, 9], swapRight = [5, 1, 11, 7];
    var flags = this.orientations.slice(0);
    for (var i = 0; i < 4; i++) {
        flags[swapLeft[i]] = this.orientations[swapRight[i]];
        flags[swapRight[i]] = this.orientations[swapLeft[i]];
    }
    return new EdgeOrientations(flags, this.eslice.flipLR(flag));
}

exports.EdgeOrientations = EdgeOrientations;

exports.generate = function(slices, prefix) {
    if (!prefix) return exports.generate(slices, []);
    if (prefix.length == 11) {
        var array = new Array(slices.length);
        for (var i = 0; i < slices.length; i++) {
            array[i] = new EdgeOrientations(prefix, slices[i]);
        }
        return array;
    }
    var list = exports.generate(slices, prefix.concat([0]));
    return list.concat(exports.generate(slices, prefix.concat([1])));
}
