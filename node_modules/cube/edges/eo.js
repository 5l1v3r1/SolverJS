var table = require('./table.js');
var State = require('../state.js').State;

function EdgeOrientations(orientations, eslice) {
    this.orientations = orientations;
    this.eslice = eslice;
    if (this.orientations.length == 11) {
        var even = true;
        for (var i = 0; i < 11; i++) {
            if (this.orientations[i]) even = !even;
        }
        if (even) this.orientations.push(false);
        else this.orientations.push(true)
    }
}

EdgeOrientations.prototype = Object.create(State.prototype);

EdgeOrientations.prototype.generateHash = function() {
    var eoHash = 0;
    for (var i = 0; i < 11; i++) {
        eoHash |= (this.orientations[i] ? 1 : 0) << i;
    }
    var sliceHash = this.eslice.hash() * (1 << 11);
    return sliceHash + eoHash;
}

EdgeOrientations.prototype.hashCount = function() {
    return (1 << 11) * this.eslice.hashCount();
}

EdgeOrientations.prototype.move = function(move) {
    var slots = null, pieces = null;
    var transformation = table.EdgeTable[move.face];
    if (move.power == 1) {
        slots = transformation[0];
        pieces = transformation[1];
    } else if (move.power == 2) {
        slots = transformation[0];
        pieces = transformation[2];
    } else if (move.power == 3) {
        slots = transformation[1];
        pieces = transformation[0];
    } else {
        throw 'Unsupported power ' + move.power;
    }
    
    var flags = this.orientations.slice(0);
    var flipFlag = move.face < 2 ? (move.power != 2) : false
    for (var i = 0; i < 4; i++) {
        var value = this.orientations[pieces[i]];
        flags[slots[i]] = flipFlag ? !value : value;
    }
    
    // change the slice edges as well and then return
    var newslice = this.eslice.move(move);
    return new EdgeOrientations(flags, newslice);
}

EdgeOrientations.prototype.moveFace = function(face) {
    // run the turn and swap EO if its F or B
    var transformation = table.EdgeTable[face];
    var flags = this.orientations.slice(0);
    var flipFlag = face < 2 ? 1 : 0;
    for (var i = 0; i < 4; i++) {
        var value = this.orientations[transformation[1][i]];
        flags[transformation[0][i]] = value ^ flipFlag;
    }
    
    // change the slice edges as well and then return
    var newslice = this.eslice.moveFace(face);
    return new EdgeOrientations(flags, newslice);
}

EdgeOrientations.prototype.rotateZ2 = function(flag) {
    if (!flag) return this;
    var newFlags = new Array(12);
    for (var i = 0; i < 12; i++) {
        newFlags[i] = this.orientations[table.EdgeZ2Rotation[i]];
    }
    return new EdgeOrientations(newFlags, this.eslice.rotateZ2(flag));
}

EdgeOrientations.prototype.rotateY = function(yPower) {
    if (yPower == 0) return this;
    
    var transformation = [table.EdgeYRotation, table.EdgeY2Rotation,
                          table.EdgeY3Rotation][yPower - 1];
    if (transformation == undefined) {
        throw 'Unsupported yPower ' + yPower;
    }
    
    // apply the transformation
    var newFlags = this.orientations;
    for (var j = 0; j < yPower; j++) {
        var nextFlags = new Array(12);
        for (var i = 0; i < 12; i++) {
            nextFlags[i] = newFlags[transformation[i]];
        }
        newFlags = nextFlags;
    }
    
    var neweslice = this.eslice.rotateY(yPower);
    
    // adjust edge orientations if necessary
    if (yPower % 2 != 0) {
        for (var i = 0; i < 12; i++) {
            if ([1,3,7,9].indexOf(i) >= 0) { // e slice slot
                if (!neweslice.isSliceEdge(i)) {
                    newFlags[i] = !newFlags[i];
                }
            } else { // U-D slot
                if (neweslice.isSliceEdge(i)) {
                    newFlags[i] = !newFlags[i];
                }
            }
        }
    }
    
    return new EdgeOrientations(newFlags, neweslice);
}

EdgeOrientations.prototype.flipLR = function(flag) {
    if (!flag) return this;
    var swapLeft = [4, 3, 10, 9], swapRight = [5, 1, 11, 7];
    var flags = this.orientations.slice(0);
    for (var i = 0; i < 4; i++) {
        flags[swapLeft[i]] = this.orientations[swapRight[i]];
        flags[swapRight[i]] = this.orientations[swapLeft[i]];
    }
    return new EdgeOrientations(flags, this.eslice.flipLR(flag));
}

exports.EdgeOrientations = EdgeOrientations;

exports.generate = function(slices, prefix) {
    if (!prefix) return exports.generate(slices, []);
    if (prefix.length == 11) {
        var array = slices.map(function(aSlice) {
            return new EdgeOrientations(prefix, aSlice);
        });
        return array;
    }
    var list = exports.generate(slices, prefix.concat([false]));
    return list.concat(exports.generate(slices, prefix.concat([true])));
}
