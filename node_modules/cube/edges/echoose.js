var table = require('./table.js');
var State = require('../state.js').State;
var choosetable = require('./choosetable.js');

// an ordered map of 12 bit integers for all 12 choose 4
// ways that E slice edges could be distributed
var chooseMap = null;

/**
 * This is a State which records the distribution of E-Slice
 * edges throughout a cube.
 */
function EChoose(flags) {
    State.call(this);
    if (flags) this.flags = flags;
    else {
        this.flags = [0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0];
    }
    this.bitFlags = choosetable.encodeChoose(this.flags);
}

EChoose.prototype = Object.create(State.prototype);

EChoose.prototype.isSliceEdge = function(anEdge) {
    return this.flags[anEdge];
}

EChoose.prototype.generateHash = function() {
    if (!chooseMap) {
        // generate E-Slice hashes
        chooseMap = choosetable.generateTable();
    }
    return chooseMap[this.bitFlags];
}

EChoose.prototype.hashCount = function() {
    return 495; // 12 choose 4
}

EChoose.prototype.move = function(move) {
    var slots = null, pieces = null;
    var transformation = table.EdgeTable[move.face];
    if (move.power == 1) {
        slots = transformation[0];
        pieces = transformation[1];
    } else if (move.power == 2) {
        slots = transformation[0];
        pieces = transformation[2];
    } else if (move.power == 3) {
        slots = transformation[1];
        pieces = transformation[0];
    } else {
        throw 'Unsupported power ' + move.power;
    }
    var flags = this.flags.slice(0);
    for (var i = 0; i < 4; i++) {
        flags[slots[i]] = this.flags[pieces[i]];
    }
    return new EChoose(flags);
}

EChoose.prototype.moveFace = function(face) {
    var transformation = table.EdgeTable[face];
    var flags = this.flags.slice(0);
    for (var i = 0; i < 4; i++) {
        flags[transformation[0][i]] = this.flags[transformation[1][i]];
    }
    return new EChoose(flags);
}

EChoose.prototype.rotateZ2 = function(flag) {
    if (!flag) return this;
    var newFlags = new Array(12);
    for (var i = 0; i < 12; i++) {
        newFlags[i] = this.flags[table.EdgeZ2Rotation[i]];
    }
    return new EChoose(newFlags);
}

EChoose.prototype.rotateY = function(yPower) {
    if (yPower == 0) return this;
    var transformation = [table.EdgeYRotation, table.EdgeY2Rotation,
                          table.EdgeY3Rotation][yPower - 1];
    if (transformation == undefined) {
        throw 'Unsupported yPower ' + yPower;
    }
    var newFlags = new Array(12);
    for (var i = 0; i < 12; i++) {
        newFlags[i] = this.flags[transformation[i]];
    }
    return new EChoose(newFlags);
}

EChoose.prototype.flipLR = function(flag) {
    if (!flag) return this;
    var swapLeft = [4, 3, 10, 9], swapRight = [5, 1, 11, 7];
    var flags = this.flags.slice(0);
    for (var i = 0; i < 4; i++) {
        flags[swapLeft[i]] = this.flags[swapRight[i]];
        flags[swapRight[i]] = this.flags[swapLeft[i]];
    }
    return new EChoose(flags);
}

exports.EChoose = EChoose;

exports.generate = function () {
    var flags = choosetable.generateChooseFlags();
    return flags.map(function (x) {
        return new EChoose(x);
    });
}
