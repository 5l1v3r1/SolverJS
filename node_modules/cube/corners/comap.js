var Move = require('../move.js').Move;
var CornerTable = require('./table.js').CornerTable;
var State = require('../state.js').State;

/**
 * Generic corner orientation map for a single axis
 */
function CoMap(orientations) {
    if (orientations) {
        this.orientations = orientations;
        if (this.orientations.length == 7) {
            this.orientations.push(this.computeLastOrientation());
        }
    } else {
        this.orientations = [1, 1, 1, 1, 1, 1, 1, 1];
    }
}

CoMap.prototype = Object.create(State.prototype);

/**
 * Computes the last corner's orientation based on
 * the first 7 corners
 */
CoMap.prototype.computeLastOrientation = function() {
    var expected = 1;
    var indexes = [3, 2, 0, 1, 5, 4, 6];
    for (var i = 0; i < 7; i++) {
        var orientation = this.orientations[indexes[i]];
        if (expected == 0) {
            expected = [1, 2, 0][orientation];
        } else if (expected == 1) {
            expected = [0, 1, 2][orientation];
        } else {
            expected = [2, 0, 1][orientation];
        }
    }
    return expected;
}

/**
 * Returns a unique index from 0 to (3^7 - 1) which corresponds
 * uniquely to this set of corner orientations
 */
CoMap.prototype.generateHash = function() {
    var hash = 0, coefficient = 1;
    for (var i = 0; i < 7; i++) {
        hash += coefficient * this.orientations[i];
        coefficient *= 3;
    }
    return hash;
}

CoMap.prototype.hashCount = function() {
    return 2187; // 3^7
}

/**
 * Applies a move directly to the face of a cube
 */
CoMap.prototype.move = function(move) {
    var slots = null, pieces = null;
    var transformation = CornerTable[move.face];
    var normalAxis = transformation[3];
    if (move.power == 1) {
        slots = transformation[0];
        pieces = transformation[1];
    } else if (move.power == 2) {
        slots = transformation[0];
        pieces = transformation[2];
    } else if (move.power == 3) {
        slots = transformation[1];
        pieces = transformation[0];
    } else {
        throw 'Unsupported power ' + move.power;
    }
    
    var target = this.orientations.slice(0);
    for (var i = 0; i < 4; i++) {
        // apply the transformation
        var slot = slots[i];
        target[slot] = this.orientations[pieces[i]];
        // apply the symmetry rotation
        if (target[slot] != normalAxis && move.power != 2) {
            if (normalAxis == 2) {
                target[slot] ^= 1;
            } else if (normalAxis == 1) {
                target[slot] = (target[slot] == 2 ? 0 : 2);
            } else {
                target[slot] = ((target[slot] - 1) ^ 1) + 1;
            }
        }
    }
    return new CoMap(target);
}

/**
 * Applies one positive turn on one face
 */
CoMap.prototype.moveFace = function(face) {
    var target = this.orientations.slice(0);
    var transformation = CornerTable[face];
    for (var i = 0; i < 4; i++) {
        // apply the transformation
        var slot = transformation[0][i];
        target[slot] = this.orientations[transformation[1][i]];
        // apply the symmetry rotation
        if (target[slot] != transformation[3]) {
            if (transformation[3] == 2) {
                target[slot] ^= 1;
            } else if (transformation[3] == 1) {
                target[slot] = (target[slot] == 2 ? 0 : 2);
            } else {
                target[slot] = ((target[slot] - 1) ^ 1) + 1;
            }
        }
    }
    return new CoMap(target);
}

CoMap.prototype.rotateZ2 = function(flag) {
    if (!flag) return this;
    return this.move(new Move(0, 2)).move(new Move(1, 2));
}

CoMap.prototype.rotateY = function(yPower) {
    if (yPower == 0) return this;
    var dPower = 4 - yPower;
    return this.move(new Move(2, yPower)).move(new Move(3, dPower));
}

CoMap.prototype.flipLR = function(flag) {
    if (!flag) return this;
    var target = new Array(8);
    for (var i = 0; i < 4; i++) {
        target[i] = this.orientations[i | 4];
        target[i | 4] = this.orientations[i];
    }
    return new CoMap(target);
}

exports.CoMap = CoMap;

exports.generate = function(prefix) {
    if (!prefix) return exports.generate([]);
    if (prefix.length == 7) {
        return [new CoMap(prefix)];
    }
    var list = [];
    for (var i = 0; i < 3; i++) {
        var next = prefix.concat([i]);
        var values = exports.generate(next);
        list = list.concat(values);
    }
    return list;
}
