var symmetry = require('symmetry');
var cube = require('cube');

var moves = cube.move.generate();
var symgroup = symmetry.udsym.generate();

function ContextState(s1, s2) {
    this.s1 = s1;
    this.s2 = s2;
}

ContextState.prototype.hash = function() {
    return this.s1.hash() + (this.s2.hash() * this.s1.hashCount());
}

ContextState.prototype.hashCount = function() {
    return this.s1.hashCount() * this.s2.hashCount();
}

/**
 * @argument s1list All state 1 objects (the objects to use symmetry on)
 * @argument s2list All state 2 objects (no symmetry to be used on these)
 */
function Context(s1list, s2list) {
    if (s1list.length == 0) throw 'Zero state 1 objects is unsupported';
    if (s2list.length == 0) throw 'Zero state 2 objects is unsupported';
     
    this.s1 = s1list;
    this.s2 = s2list;
    
    this.symtable = new symmetry.SymTable(s1list);
    this.generateS2Inv();
    this.hashLength = this.symtable.perfectHashCount() * this.s2[0].hashCount();
}

Context.prototype.generateS2Inv = function() {    
    this.s2InvTable = new Array(this.s2[0].hashCount());
    for (var i = 0; i < this.s2[0].hashCount(); i++) {
        this.s2InvTable[this.s2[i].hash()] = this.s2[i];
    }
}

/**
 * Takes a least state and applies a move to it, returning another least
 * state.
 */
Context.prototype.moveState = function(state, moveIndex) {
    var s1Result = state.s1.move(moves[moveIndex]);
    var s2Result = state.s2.move(moves[moveIndex]);
    return new ContextState(s1Result, s2Result);
}

/**
 * Returns the hash of a state (not necessary a least state).
 */
Context.prototype.hashState = function(state) {
    var object = this.symtable.leastSymmetry(state.s1);
    var symS1 = object.state;
    var symS2 = state.s2.symmetrize(object.sym);
    
    if (state.s1.symmetrize(object.sym).hash() != symS1.hash()) {
        throw 'failed to symmetrize shhit';
    }
    
    var symS1Hash = this.symtable.perfectHash(symS1);
    var hash = symS2.hash() + (symS2.hashCount() * symS1Hash);
    return hash;
}

Context.prototype.hashCount = function() {
    return this.hashLength;
}

Context.prototype.unhashState = function(hash) {
    var sym2Hash = hash % this.s2[0].hashCount();
    var sym1Hash = (hash - sym2Hash) / this.s2[0].hashCount();
    
    var s1 = this.symtable.perfectUnhash(sym1Hash);
    var s2 = this.s2InvTable[sym2Hash];
    
    var thes1 = this.symtable.leastSymmetry(s1);
    s2 = s2.symmetrize(thes1.sym.inverse());
    
    return new ContextState(s1, s2);
}

exports.Context = Context;
exports.ContextState = ContextState;

/** Methods **/

function moveCacheForStates(states) {
    var array = new Array(states[0].hashCount());
    for (var i = 0; i < states[0].hashCount(); i++) {
        array[i] = null;
    }
    for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var results = [];
        for (var j = 0; j < moves.length; j++) {
            results.push(state.move(moves[j]));
        }
        array[state.hash()] = results;
    }
    return array;
}

exports.moveCacheForStates = moveCacheForStates;

exports.standardContext = function() {
    var eSlices = cube.edges.echoose.generate();
    var edgeConfigs = cube.edges.eo.generate(eSlices);
    var cornerConfigs = cube.corners.comap.generate();
    return new Context(edgeConfigs, cornerConfigs);
}
