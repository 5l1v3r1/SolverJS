var symmetry = require('symmetry');
var cube = require('cube');

var moves = cube.move.generate();
var symgroup = symmetry.udsym.generate();

function ContextState(s1, s2) {
    this.s1 = s1;
    this.s2 = s2;
}

/**
 * @argument s1list All state 1 objects (the objects to use symmetry on)
 * @argument s2list All state 2 objects (no symmetry to be used on these)
 */
function Context(s1list, s2list) {
    if (s1list.length == 0) throw 'Zero state 1 objects is unsupported';
    if (s2list.length == 0) throw 'Zero state 2 objects is unsupported';
     
    this.s1 = s1list;
    this.s2 = s2list;
    
    this.symtable = new symmetry.SymTable(s1list);
    this.generateCache1();
    this.generateCache2();
    this.hashLength = this.s1Cache.length * this.s2Cache.length;
}

Context.prototype.generateCache1 = function() {
    var states = this.symtable.getAllLeastStates();
    // generate hashes for each one
    this.s1Cache = new Array(this.symtable.perfectHashCount());
    for (var i = 0; i < this.symtable.perfectHashCount(); i++) {
        this.s1Cache[i] = null;
    }
    for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var hash = this.symtable.perfectHash(state);
        var results = [];
        for (var j = 0; j < moves.length; j++) {
            results.push(state.move(moves[j]));
        }
        this.s1Cache[hash] = results;
    }
}

Context.prototype.generateCache2 = function() {
    this.s2Cache = moveCacheForStates(this.s2);
}

/**
 * Takes a least state and applies a move to it, returning another least
 * state.
 */
Context.prototype.moveState = function(state, moveIndex) {
    var thes1 = this.symtable.leastSymmetry(state.s1);
    var perfectHash = this.symtable.perfectHash(thes1.state);
    var s1Result = this.s1Cache[perfectHash][moveIndex];
    var s2Result = this.s2Cache[state.s2.symmetrize(thes1.sym).hash()][moveIndex];
    return new ContextState(s1Result, s2Result);
}

/**
 * Returns the hash of a state (not necessary a least state).
 */
Context.prototype.hashState = function(state) {
    var object = this.symtable.leastSymmetry(state.s1);
    var symS1 = object.state;
    var symS2 = state.s2.symmetrize(object.sym);
    var symS1Hash = this.symtable.perfectHash(symS1);
    var hash = symS2.hash() + (symS2.hashCount() * symS1Hash);
    return hash;
}

Context.prototype.hashCount = function() {
    return this.hashLength;
}

exports.Context = Context;
exports.ContextState = ContextState;

/** Methods **/

function moveCacheForStates(states) {
    var array = new Array(states[0].hashCount());
    for (var i = 0; i < states[0].hashCount(); i++) {
        array[i] = null;
    }
    for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var results = [];
        for (var j = 0; j < moves.length; j++) {
            results.push(state.move(moves[j]));
        }
        array[state.hash()] = results;
    }
    return array;
}

exports.moveCacheForStates = moveCacheForStates;

exports.standardContext = function() {
    var eSlices = cube.edges.echoose.generate();
    var edgeConfigs = cube.edges.eo.generate(eSlices);
    var cornerConfigs = cube.corners.comap.generate();
    return new Context(edgeConfigs, cornerConfigs);
}
