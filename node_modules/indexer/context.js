var symmetry = require('symmetry');
var cube = require('cube');

var moves = cube.move.generate();
var symgroup = symmetry.udsym.generate();

/**
 * @argument s1list All state 1 objects (the objects to use symmetry on)
 * @argument s2list All state 2 objects (no symmetry to be used on these)
 */
function Context(s1list, s2list) {
    if (s1list.length == 0) throw 'Zero state 1 objects is unsupported';
    if (s2list.length == 0) throw 'Zero state 2 objects is unsupported';
     
    this.s1 = s1list;
    this.s2 = s2list;
    
    this.symtable = new symmetry.SymTable(s1list);
    this.generateCache1();
    this.generateCache2();
}

Context.prototype.generateCache1 = function() {
    var states = this.symtable.getAllLeastStates();
    this.s1Cache = moveCacheForStates(states);
}

Context.prototype.generateCache2 = function() {
    this.s2Cache = moveCacheForStates(this.s2);
}

Context.prototype.moveS1 = function(state, moveIndex) {
    var theState = this.symtable.leastSymmetry(state).state;
    return this.s1Cache[theState.hash().toString()][moveIndex];
}

Context.prototype.moveS2 = function(state, moveIndex) {
    return this.s2Cache[state.hash().toString()][moveIndex];
}

Context.prototype.hashState = function(s1, s2) {
    // get symmetry object for s1
    var object = this.symtable.leastSymmetry(s1);
    var symS1 = object.state;
    var symS2 = s2.symmetrize(object.sym);
    var hash = symS1.hash() + (symS1.hashCount() * symS2.hash());
    return hash;
}

Context.prototype.hashCount = function() {
    return Object.keys(this.s1Cache).length * Object.keys(this.s2Cache).length;
}

exports.Context = Context;

/** Methods **/

function moveCacheForStates(states) {
    var object = {};
    for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var results = [];
        for (var j = 0; j < moves.length; j++) {
            results.push(state.move(moves[j]));
        }
        object[state.hash().toString()] = results;
    }
    return object;
}

exports.moveCacheForStates = moveCacheForStates;

exports.standardContext = function() {
    var eSlices = cube.edges.echoose.generate();
    var edgeConfigs = cube.edges.eo.generate(eSlices);
    var cornerConfigs = cube.corners.comap.generate();
    return new Context(edgeConfigs, cornerConfigs);
}
