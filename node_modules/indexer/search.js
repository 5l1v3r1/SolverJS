var Table = require('./table.js').Table;
var ContextState = require('./context').ContextState;
var FastList = require('fast-list');

function Node(state, depth) {
    this.state = state;
    this.depth = depth;
}

function Search(context, s1Id, s2Id) {
    this.context = context;
    this.table = new Table(context.hashCount());
    this.seenTable = new Array();
    this.nodeCount = 0;
    
    for (var i = 0; i < this.context.hashCount(); i++) {
        this.table.setValue(i, 15);
    }
    
    this.identity = new ContextState(s1Id, s2Id);
    
    // fields used for backsearch
    this.backsearch = null;
    this.startHash = null;
}

Search.prototype.expand = function(s) {
    var states = new Array();
    var foundHashes = new Array();
    for (var i = 0; i < 18; i++) {
        var newState = this.context.moveState(s.state, i);
        var node = new Node(newState, s.depth + 1);      
        states.push(node);
    }
    return states;
}

/** Forward search functions **/

Search.prototype.nextIteration = function(depth, node) {
    if (!node) {
        return this.nextIteration(depth, new Node(this.identity, 0));
    }
    
    var hash = this.context.hashState(node.state);
    var pruneValue = this.table.getValue(hash);
        
    if (pruneValue == 15) {
        this.table.setValue(hash, node.depth);
        this.nodeCount++;
        if (this.nodeCount % 100000 == 0) {
            console.log('node count is ' + this.nodeCount);
        }
    } else {
        // this node has already been seen
        if (pruneValue < node.depth) return;
        if (this.seenTable[node.state.hash()] == depth) {
            return;
        } else {
            this.seenTable[node.state.hash()] = depth;
        }
    }
    
    if (node.depth == depth) return;
    
    var expanded = this.expand(node);
    for (var i = 0; i < expanded.length; i++) {
        this.nextIteration(depth, expanded[i]);
    }
    
    return;
}

/** Backwards search **/

Search.prototype.iterateBacksearch = function(depth) {
    for (var i = 0; i < this.context.hashCount(); i++) {
        if (this.table.getValue(i) == 15) {
            var state = this.context.unhashState(i);
            if (this.backsearchNode(new Node(state, depth))) {
                this.nodeCount++;
            }
        }
    }
}

Search.prototype.backsearchNode = function(node) {
    var expanded = this.expand(node);
    for (var i = 0; i < expanded.length; i++) {
        var hash = this.context.hashState(expanded[i].state);
        var value = this.table.getValue(hash);
        if (value != 15) {
            if (value = node.depth - 1) {
                this.table.setValue(this.context.hashState(node.state), node.depth);
                return true;
            }
        }
    }
    return false;
}

Search.prototype.initiateBacksearch = function() {
    // free all this unused memory
    this.backsearch = [];
    this.setupNextNode();
}

Search.prototype.generateNotFound = function(maximum) {
    var notFound = new Array();
    for (var i = 0; i < this.context.hashCount(); i++) {
        if (this.table.getValue(i) == 15) {
            notFound.push(i);
            if (notFound.length == maximum) break;
        }
    }
    this.backsearch = notFound;
}

Search.prototype.setupNextNode = function() {
    if (this.backsearch.length == 0) {
        this.generateNotFound(1000000);
        if (this.backsearch.length == 0) return false;
    }
    var stateHash = this.backsearch.pop();
    var state = this.context.unhashState(stateHash);
    this.nodes = new FastList();
    this.nodes.push(new Node(state, 0));
    this.startHash = stateHash;
    return true;
}

Search.prototype.nextBacksearch = function(maxReversal, forwardDepth) {
    if (this.nodes.length == 0) {
        return false;
    }
    
    var node = this.nodes.shift();
    var hash = this.context.hashState(node.state);
    var pruneValue = this.table.getValue(hash);
        
    if (this.depth != node.depth) {
        this.depth = node.depth;
        console.log('depth is ' + this.depth)
    }
    
    if (pruneValue <= forwardDepth) {
        console.log('we found a node');
        // we found an initial node, so we are done
        if (pruneValue != forwardDepth) throw 'screwball ' + pruneValue + ' ' + forwardDepth + ' ' + node.depth;
        
        var depth = node.depth + forwardDepth;
        console.log('setting depth ' + depth);
        
        if (depth <= forwardDepth) {
            throw 'foo';
        }
        
        this.table.setValue(this.startHash, depth);
        this.nodeCount++;
        return this.setupNextNode();
    }
    
    if (node.depth == maxReversal) return true;
    var expanded = this.expand(node);
    for (var i = 0; i < expanded.length; i++) {
        this.nodes.push(expanded[i]);
    }
    
    return true;
}

exports.Search = Search;