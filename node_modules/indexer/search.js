var Table = require('./table.js').Table;

function SearchNode(s1, s2) {
    this.s1 = s1;
    this.s2 = s2;
}

function Search(context, s1Id, s2Id) {
    this.context = context;
    this.table = new Table(context.hashCount());
    this.iterationTable = new Table(context.hashCount());
    this.nodeCount = 0;
    
    for (var i = 0; i < this.context.hashCount(); i++) {
        this.table.setValue(i, 15);
        this.iterationTable.setValue(i, 0);
    }
    
    this.identity = new SearchNode(s1Id, s2Id);
    this.identity.moves = [];
}

Search.prototype.nextIteration = function(depth, currentDepth, node) {
    if (currentDepth == undefined || node == undefined) {
        return this.nextIteration(depth, 0, this.identity);
    }
    
    var hash = this.context.hashState(node.s1, node.s2);
    var pruneValue = this.table.getValue(hash);
        
    if (pruneValue == 15) {
        this.table.setValue(hash, currentDepth);
        this.nodeCount++;
    } else {
        // this node has already been seen
        var iterationValue = this.iterationTable.getValue(hash);
        if (iterationValue == depth) {
            //console.log(hash + ' already claimed before ' + node.moves);
            //return;
        } else {
            this.iterationTable.setValue(hash, depth);
            //console.log('claiming ' + hash + ' with ' + node.moves);
        }
    }
    
    if (currentDepth == depth) return;
    
    var expanded = this.expand(node);
    for (var i = 0; i < expanded.length; i++) {
        this.nextIteration(depth, currentDepth + 1, expanded[i]);
    }
    
    return;
}

Search.prototype.expand = function(s) {
    var states = new Array();
    var foundHashes = new Array();
    for (var i = 0; i < 18; i++) {
        var newS1 = this.context.moveS1(s.s1, i);
        var newS2 = this.context.moveS2(s.s2, i);
        
        var hash = this.context.hashState(newS1, newS2);
        if (foundHashes.indexOf(hash) >= 0) continue;
        
        var aState = new SearchNode(newS1, newS2);
        aState.moves = s.moves.concat([i]);
        states.push(aState);
    }
    return states;
}

exports.Search = Search;